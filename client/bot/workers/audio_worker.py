import os
import tempfile
import asyncio
import logging
from pydub import AudioSegment
import numpy as np
from kokoro import KPipeline
import soundfile as sf

from bot.processing import redis_client
from bot.utilities import replace_userids_with_username
from bot.constants import (
    DERF_AUDIO_QUEUE,
    DERF_PLAYBACK_QUEUE,
    NIC_AUDIO_QUEUE,
    NIC_PLAYBACK_QUEUE,
    TTS_VOICE,
    TTS_VOICE_NICOLE,
)

logger = logging.getLogger(__name__)
pipeline = KPipeline(lang_code="a")  # english


def process_kokoro_audio(line_text, voice, output_wav):
    """Sync function to handle kokoro TTS generation and file writing."""
    try:
        generator = pipeline(line_text, voice)
        audio_segments = []
        for _, _, audio in generator:
            audio_segments.append(audio)

        if not audio_segments:
            raise RuntimeError("No audio generated by kokoro")

        full_audio = np.concatenate(audio_segments)  # Ensure numpy is imported
        sf.write(output_wav, full_audio, 24000)
    except Exception as e:
        logger.error(f"Kokoro processing failed: {str(e)}")
        raise


def convert_wav_to_opus(wav_path, opus_path):
    """Sync function to convert WAV to OPUS."""
    audio_segment = AudioSegment.from_wav(wav_path)
    audio_segment.export(opus_path, format="opus", parameters=["-b:a", "128k"])


async def audio_task(queue_name, playback_queue_name, tts_voice, bot_instance):
    output_dir = "/home/j/dorf/client/output/"
    loop = asyncio.get_event_loop()  # Reuse the same event loop
    while True:
        task_data = await loop.run_in_executor(None, redis_client.rpop, queue_name)

        if not task_data:
            await asyncio.sleep(1)
            continue

        unique_id, line_number, line_text = task_data.split("|", 2)
        line_text = await replace_userids_with_username(
            line_text
        )  # Assuming this is async

        num_users = (
            len(bot_instance.voice_clients[0].channel.members) - 1
            if bot_instance.voice_clients
            else 0
        )

        if num_users < 1:
            logger.info(f"Skipping audio generation for {num_users} users.")
            continue

        wav_path = os.path.join(output_dir, f"{line_number}.wav")

        try:
            await loop.run_in_executor(
                None, process_kokoro_audio, line_text, tts_voice, wav_path
            )
        except Exception as e:
            logger.error(f"Kokoro error for {line_text}: {str(e)}")
            continue

        if not os.path.exists(wav_path):
            logger.error(f"WAV missing: {wav_path}")
            continue

        # Convert to OPUS
        with tempfile.NamedTemporaryFile(delete=False, suffix=".opus") as tmp_opus:
            opus_path = tmp_opus.name

            await loop.run_in_executor(None, convert_wav_to_opus, wav_path, opus_path)

            # Push to playback queue without blocking
            await loop.run_in_executor(
                None,
                redis_client.lpush,
                playback_queue_name,
                f"{unique_id}|{opus_path}",
            )


async def nic_audio_task(bot):
    await audio_task(
        queue_name=NIC_AUDIO_QUEUE,
        playback_queue_name=NIC_PLAYBACK_QUEUE,
        tts_voice=TTS_VOICE_NICOLE,
        bot_instance=bot,
    )


async def derf_audio_task(bot):
    await audio_task(
        queue_name=DERF_AUDIO_QUEUE,
        playback_queue_name=DERF_PLAYBACK_QUEUE,
        tts_voice=TTS_VOICE,
        bot_instance=bot,
    )
